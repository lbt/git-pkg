#!/usr/bin/python

# make_src
# This is part of the Mer git-packaging suite
# It takes a _src file and recreates any tarballs referenced in it.
#
# 3 types:
# native: extract the tarball using git archive <tag>
# upstream git: additionally use git format-patch to make patches
# pristine tar: use ptar and then git format-patch
# upstream with released tarball: as pristine tar but skip the commit
#   labelled "pristine-tar" in the mer-<version> branch

import re
import os
import subprocess
import argparse
import sys

pkg_branch="pkg-mer"

# Allow overriding of "git' command via the "GIT" environment variable
GIT_CMD = os.environ.get('GIT', 'git')

class UnknownFormat(Exception):
    pass

def git(*args):
    """Run git with arguments, return stdout as string"""
    return subprocess.check_output([GIT_CMD] + list(args))

def fail(msg, *args):
    """Report an error message and exit with failure"""
    print >>sys.stderr, 'ERROR:', msg % args
    sys.exit(1)

def checkout_packaging_branch(pkg, force):
    """
    Ensure we're on the latest packaging branch commit.
    If force is False and we're on the packaging branch then no-op
    (this essentially lets us run with uncommited changes to _src,
    spec etc so the patch-sets can be added.)
    """
    if force:
        git('checkout', '-f', pkg)

    try:
        branch = git('symbolic-ref', 'HEAD').replace('refs/heads/', '').rstrip()
    except subprocess.CalledProcessError:
        return # We're not on a symbolic ref; assume tag

    if not force and branch != pkg:
        fail('Must be on the %s branch to use --no-checkout', pkg)

def guess_format(archive):
    if (re.search(r'\.t(ar\.)?gz$', archive)):
        return ("tar", "gzip")
    elif (re.search(r'\.tar\.bz2$', archive)):
        return ("tar", "bzip2")
    else:
        raise UnknownFormat()

def count_commits(a, b):
    return len(git('rev-list', '..'.join((a, b))).splitlines())


def prepare_tarball_and_patches():
    src_f = open("_src")

    for src in src_f:
        src = src.rstrip()
        src = src.split(":")
        vcs = src[0]
        tag1, tag2 = None, None

        if vcs.startswith("#"):
            continue

        if (vcs == "git" ):
            # git:<tarball>:<tag1>:<tag2>
            # make a tarball at tag1 and patches to tag2 (if present)
            if len(src) < 3:
                raise Exception("Not enough arguments for 'git' line in _src")

            tarball, tag1 = src[1:3]
            if len(src) > 3:
                tag2 = src[3]

            # Determine archive/compression
            try:
                format, compression = guess_format(tarball)
                # Make a suitable tarball
                subprocess.call(
                    GIT_CMD + " archive --format=%(format)s --prefix=src/ %(tag1)s "
                    "| %(compression)s > %(tarball)s" % locals(),
                    shell=True)
            except UnknownFormat :
                fail("Can't determine format of tarball %s", tarball)

        elif (vcs == "pristine-tar"):
            # pristine-tar:<tarball>:<tag1>:<tag2>
            # extract upstream tarball and make patches from tag1 to tag2
            # (if present) skipping the special 'pristine-tar' diff patch
            if len(src) < 3:
                raise Exception("Not enough arguments for 'pristine-tar' line in _src")

            tarball, tag1 = src[1:3]
            if len(src) > 3:
                tag2 = src[3]

            # For pristine tar style repos the first commit is the
            # pristine tar delta stored in a commit labeled pristine-tar-delta
            # Skip the first commit using commit~N terminology
            tag1 = "%s~%d" %(tag2, count_commits(tag1, tag2) - 1)

            subprocess.call(
                [ "/usr/bin/pristine-tar", "checkout", tarball],
                shell=False)
    #        raise Exception("Pristine tar not done yet")

        else:
            raise Exception("_src storage %s not recognised" % vcs)

        # If a tag range was specified, create patches
        # -M is --find-renames but that's not available on suse 11.4
        if tag2:
            patches = git('format-patch', '-M', '--binary', '--no-renames',
                    '-N', '--no-numbered', '..'.join((tag1, tag2))).splitlines()

            print "Patch source entries and %patch entries for .spec file\n"
            count = 1
            for patch in patches:
                print "Patch%(count)d: %(patch)s" % locals()
                count+=1

            print
            count = 1
            for patch in patches:
                print "%%patch%(count)d -p1" % locals()
                count+=1

            print "\nPatches entries for Spectacle .yaml file\n"
            print "Patches:"
            for patch in patches:
                print "- %(patch)s" % locals()
        else:
            print "No patches requested"

parser = argparse.ArgumentParser(description='gitpkg build preparation')
parser.add_argument('-n', '--no-checkout',
                    dest='force_checkout', action='store_false',
                    help="Don't force checkout the latest pkg branch (useful if working on packaging)")
parser.add_argument('tag', metavar='tag', type=str, nargs='?',
                    default=pkg_branch,
                    help='A tag to force checkout')
args = parser.parse_args()

# Checkout the tag (default is the hardcoded pkg_branch)
checkout_packaging_branch(args.tag, args.force_checkout)
prepare_tarball_and_patches()
